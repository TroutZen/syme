'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=require('react');var _react2=_interopRequireDefault(_react);var _reactDom=require('react-dom');var _reactDom2=_interopRequireDefault(_reactDom);var _model=require('./model.js');var _model2=_interopRequireDefault(_model);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**\

    ModelListener
        watches models for updates, when the update is passed through
        the param.model field. If a param named watchOnly is sent, the
        view will only update when those fields are updated in the model

\**/var ModelListener=function(_React$Component){_inherits(ModelListener,_React$Component);function ModelListener(props){_classCallCheck(this,ModelListener);var bindWatch=void 0,ni=void 0;if(!props.hasOwnProperty('model')){throw new Error('ModelListener requires a model');}var _this=_possibleConstructorReturn(this,(ModelListener.__proto__||Object.getPrototypeOf(ModelListener)).call(this,props));_this.model=null;if(props.model instanceof _model2.default){// already initialized model
_this.model=props.model;}else if(props.model.prototype instanceof _model2.default){// just a definition
_this.model=new props.model();}else{try{//just a json object
_this.model=new _this.constructor.defaultProps.model(props.model);}catch(e){throw new Error('A model listener needs a '+'model definition somewhere');}}if(!_this.props.hasOwnProperty('watchOnly')){_this.model.onUpdate('*',_this._update.bind(_this));}else{bindWatch=function(key){this.model.onUpdate(key,this._update.bind(this));}.bind(_this);for(ni=0;ni<_this.props.watchOnly.length;ni++){bindWatch(_this.props.watchOnly[ni]);}}return _this;}_createClass(ModelListener,[{key:'_update',value:function _update(){/* istanbul ignore else: can't test server side rendering */if(typeof window!=='undefined'&&this.node){this.setState(this.state||{});}}},{key:'componentDidMount',value:function componentDidMount(){this.node=_reactDom2.default.findDOMNode(this);}},{key:'componentWillUnmount',value:function componentWillUnmount(){/* istanbul ignore next: cant unmount */this.node=null;}},{key:'update',value:function update(field,value){var _state={};_state[field]=value;this.model.fill(_state);}}]);return ModelListener;}(_react2.default.Component);exports.default=ModelListener;